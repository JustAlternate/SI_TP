\documentclass{article}

\usepackage[margin=0.3in]{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{minted}


\author{Loïc Weber \& Thibault Gounant} 
\title{Cahier de TP}

\begin{document}

\setlength\parindent{0pt}

\maketitle

\renewcommand*\contentsname{Table des matières}
\tableofcontents

\section{TP1 : Unix, le système de fichier}

\subsection{Manuel}
\begin{minted}{bash}
man <commande>          # Afficher les pages du manuel correspondant à la commande
whatis <commande>       # Afficher la description du manuel correspondant à la commande
apropos <mot>           # Afficher les descriptions du manuel dont les pages contienent le mot 
history                 # Afficher l'historique des commandes
alias <commande>=<expr> # Créer une commande correspondant à une expression
\end{minted}

\subsection{Hierarchie}
\begin{minted}{bash}
/    # Répertoire racine
..   # Répertoire parent
~    # Répertoire maison
\end{minted}

\begin{minted}{bash}
ls <dossier>    # Afficher le contenu du dossier
pwd             # Afficher le chemin absolu du dossier courant
cd <dossier>    # Changer de dossier
tree            # Afficher l'arborescence de répertoires
\end{minted}

\subsection{Affichage}
\begin{minted}{bash}
file <fichier>  # Afficher une description du type du fichier
cat <fichier>   # Afficher le contenu du fichier
sort <fichier>  # Afficher le contenu du fichier trié
more <fichier>  # Visualiser le contenu du fichier par le haut
less <fichier>  # Visualiser le contenu du fichier par le bas
\end{minted}

\subsection{Gestion}
\begin{minted}{bash}
mkdir <dossier>             # Créer le dossier
rmdir <dossier>             # Supprimer le dossier vide
touch <fichier>             # Créer le fichier
rm <fichier>                # Supprimer le fichier
cp <fichier> <dossier>      # Copier le fichier dans le dossier
mv <fichier> <dossier>      # Déplacer le fichier dans le dossier
ln <fichier1> <fichier2>    # Créer un raccourci fichier1 vers le fichier2 
\end{minted}

\section{TP2 : Commandes utilisateur Unix}

\subsection{Droits des fichiers}

\begin{minted}{bash}
chmod <droit> <fichier>   # Changer les droits du fichier
\end{minted}

Unix attribue à tous les fichiers deux choses :

\begin{itemize}
  \item Un créateur et un groupe.
  \item Une liste de droits pour le créateur, le groupe et pour tous les autres (les triplets)
\end{itemize}

Exemple de droit pour le dossier "Projects" visible avec la commande "ls -l" : 
\begin{minted}{bash}
drwxr-xr-x 17 justalternate root           4096 Aug  2 18:37 Projects
\end{minted}
Les 10 premiers caractères représente :
\begin{itemize}
  \item Le type de fichier (d = directory, - = regular file, l = symbolic link, p = pipe, s = socket ..)
  \item Les 3 premiers droits créateur (rwx = tous les droits)
  \item 3 droits du groupe (r-x)
  \item 3 droits pour tous les autres (r-x)
  \item le créateur (justalternate)
  \item le groupe associé (root)
\end{itemize}

Afin de modifier les droits d'un fichier, on peut d'abord agir sur les droits créateur, groupe et autre :

\begin{minted}{bash}
chmod +x fichier    # Donne à tous les utilisateurs la permission d'exécution
chmod u+r fichier   # Donne au proprietaire la permission de lecture
chmod g+w fichier   # Donne au groupe la permission d'écriture
chmod o+x fichier   # Donne au autre la permission d'exécution
chmod a-r fichier   # Enlève a tous (u,g,o) les permissions de lecture
chmod u+s fichier   # Donne les mêmes droits que le proprietaire a l'utilisateur
chmod o+t fichier   # Seul le proprietaire a la permission d'exécution
\end{minted}

On peut ensuite modifier le groupe ou bien le créateur :

\begin{minted}{bash}
chgrp IDIA2026 Systeme_Info # Change le groupe du fichier "Systeme_Info" en "IDIA2026"
chown IDIA2026 Systeme_Info # Change le createur du fichier "Systeme_Info" en "IDIA2026"
\end{minted}

\subsection{Système}
\begin{itemize}
  \item /etc/fstab : liste les montages disponibles
  \item /etc/mtab : liste les points actuellement montés
\end{itemize}
\begin{minted}{bash}
df <fichier>    # Occupation disque du fichier
mount           # Monte un systeme de fichiers dans un répertoire de l'arborescence
\end{minted}

\subsection{Redirection}
Dans Unix, on peut rediriger la sortie d'une commande dans un fichier ou bien utiliser un fichier en tant qu'arguments pour une commande.
\begin{minted}{bash}
ls > listefichiers.txt
\end{minted}

Cette commande crée (ou écrase) le fichier "listefichiers.txt" avec le résultat de la commande "ls".

D'autres types de redirection :

\begin{itemize}
  \item $>>$    \# Permet d'ajouter à la fin (append)
  \item $<$    \# Permet d'utiliser le contenu d'un fichier pour exécuter la commande.
  \item $2>\&1$ \# Permet d'ajouter les potentielles erreurs de la commande dans le fichier
\end{itemize}

Le pipe 
\begin{minted}{bash}
<commande1> | <commande2>
\end{minted}
 la sortie de la première commande devient l'entrée de la deuxième commande

\subsection{Recherche}
\begin{minted}{bash}
find <expr>             # Rechercher un fichier
grep <expr> <fichier>   # Rechercher une expression dans le fichier
\end{minted}

\section{TP3 : Commandes utiles}

\subsection{Traitement des fichiers}
\begin{minted}{bash}
  head <fichier>    # Premières lignes du fichier
  tail <fichier>    # Dernières lignes du fichier
  split <fichier>   # Fractionnement du fichier en plusieurs
  cut <fichier>     # Fractionnement vertical du fichier  
\end{minted}

sed
Permet de remplacer des occurences de mots dans un fichier.
\begin{minted}{bash}
sed 's/Hello/Bonjour/g' fichier.txt #-> remplace 'Hello' par 'Bonjour' dans le fichier.txt
\end{minted}

tr
Permet de remplacer à petite échelle.

\begin{minted}{bash}
echo toto | tr o a      #-> tata
echo hello | tr heo abc #-> abllc
\end{minted}

\subsection{Compression et archivage}
\begin{minted}{bash}
  gzip <fichier>    # Compréssion du fichier
  gunzip <fichier>  # Decompréssion du fichier
  zip <fichier>     # Compréssion et archivage du fichier
  unzip <fichier>   # Extraction du contenu
  tar <fichiers>    # Archivage des fichiers
\end{minted}

diff
Permet de comparer deux fichiers lignes par lignes et d'afficher les lignes différentes.
\begin{minted}{bash}
diff fichier1 fichier2
\end{minted}

uniq
Permet de ne pas tenir compte des répétitions.
\begin{minted}{bash}
uniq fichier
\end{minted}

comm
Permet de comparer deux fichiers triés ligne par ligne et d'afficher les lignes communes.
\begin{minted}{bash}
comm fichier1 fichier2
\end{minted}

\section{Le Shell}

Tous les scripts bash ont une extension .sh pour les exécuter dans l'invite de commande ont fait ./mon\_script.sh attention de bien avoir la permission d'exécuter le fichier\dots

Pour passer des arguments a notre script ont fait :
\begin{minted}{bash}
./mon_script arg1 arg2 arg3
\end{minted}

Et pour retrouver ces arguments ont fait :

\begin{minted}{bash}
$1 # arg1
$2 # arg2

$# # le nombre d'arguments
$@ # tous les arguments sous la forme de liste
$* # tous les arguments sous la forme d'une chaîne de caractere

$0 # le nom du script (avec le ./)
$? # 1 si la commande précédente a fait une erreur sinon 0
\end{minted}

Pour créer une variable ont fait :

\begin{minted}{bash}
ma_var=1 # Attention a bien coller 'ma_var' au '=' sinon ça ne marche pas.
mon_entier=-4
mon_string="chaine de caractère"
\end{minted}

Pour utiliser une variable déjà définit, on mettra systématiquement un \$ ou bien, on encapsulera la variable demandée par des \`{} \`{}

\begin{minted}{bash}
echo $ma_var  #-> affiche 1
echo `ma_var`  #-> affiche 1
var2=$ma_var  #-> copie ma_var dans var2
\end{minted}

Afin de former une expression avec nos variables, on utilise le mot 'expr' :

\begin{minted}{bash}
echo $(expr $ma_var + 1)    #-> affiche 2
ma_var=$(expr $ma_var + 1)  #-> incrémente la variable "ma_var"
\end{minted}

ATTENTION le \$ derrière la parenthèse du "expr" est indispensable !

\end{document}
